use serde::{Deserialize, Serialize};
use std::io::{BufWriter, Write};
use std::process::Command;
use std::{
    collections::HashMap,
    fs::{self, File},
    path::PathBuf,
};
use walkdir::WalkDir;

mod errors;
use errors::Error;
mod parsing;
use parsing::{parse, Statement};

#[macro_use]
extern crate lazy_static;

fn builtin_mappings(data_type: &str) -> Option<&'static str> {
    lazy_static! {
        static ref MAPPING: HashMap<&'static str, &'static str> = vec![
            ("bool", "bool"),
            ("byte", "u8"),
            ("char", "char"),
            ("float32", "f32"),
            ("float64", "f64"),
            ("int8", "i8"),
            ("int16", "i16"),
            ("int32", "i32"),
            ("int64", "i64"),
            ("uint8", "u8"),
            ("uint16", "u16"),
            ("uint32", "u32"),
            ("uint64", "u64"),
            ("string", "std::string::String"),
            ("time", "frost::time::Time"), // Type manually generated
            ("duration", "frost::time::RosDuration") // Type manually generated
        ].into_iter().collect();
    }
    MAPPING.get(data_type).copied()
}

#[derive(Debug)]
struct RosMsg {
    name: String,
    statements: Vec<Statement>,
}

impl RosMsg {
    fn new(path: &PathBuf) -> Result<Self, Error> {
        let text = fs::read_to_string(path)?;

        Ok(RosMsg {
            name: path.file_stem().unwrap().to_string_lossy().into_owned(),
            statements: parse(&text)?,
        })
    }

    fn as_struct_definition(&self) -> String {
        let mut buf = String::new();
        buf.push_str(&format!("pub struct {} {{", &self.name));

        self.statements.iter().for_each(|stmt| {
            let msg_type = stmt.get_type();
            let name = stmt.get_name();

            let full_type_name = match &msg_type.package_name {
                Some(package_name) => package_name.clone() + "::" + &msg_type.name,
                None => builtin_mappings(&msg_type.name)
                    .unwrap_or(&msg_type.name)
                    .to_owned(),
            };
            buf.push_str("pub ");
            buf.push_str("r#"); // use raw identifiers just in case
            buf.push_str(name);
            buf.push_str(": ");
            if msg_type.is_array {
                buf.push_str(&format!("Vec<{}>", &full_type_name));
            } else {
                buf.push_str(&full_type_name);
            }
            buf.push(',')
        });

        buf.push('}');

        buf
    }
}

#[derive(Clone, Debug)]
struct Opts {
    input_path: PathBuf,
    output_path: PathBuf,
}

fn build_parser() -> impl bpaf::Parser<Opts> {
    let input_path = bpaf::short('i')
        .long("input_path")
        .help("Path to a root folder containing ros msg files.")
        .argument::<PathBuf>("INPUT_PATH");

    let output_path = bpaf::short('o')
        .long("output_path")
        .help("Path to a folder which will contain generated Rust files.")
        .argument::<PathBuf>("OUTPUT_PATH");

    bpaf::construct!(Opts {
        input_path,
        output_path
    })
}

// Helper struct for parsing package.xml
#[derive(Debug, Serialize, Deserialize, PartialEq)]
struct Package {
    name: String,
}

fn get_package_name(path: &PathBuf) -> Result<String, Error> {
    let xml_string = fs::read_to_string(path)?;
    let res: Package = serde_xml_rs::from_str(&xml_string)?;
    Ok(res.name)
}

fn fmt_file(path: &PathBuf) -> Result<(), Error> {
    let mut fmt_cmd = Command::new("rustfmt");
    fmt_cmd.arg(path).output()?;
    Ok(())
}

fn write_all(
    out_path: &PathBuf,
    mods: HashMap<String, String>,
    msgs: Vec<(PathBuf, RosMsg)>,
) -> Result<(), Error> {
    let file = File::create(out_path)?;
    let mut writer = BufWriter::new(file);

    writer.write_all(b"#![allow(clippy::all)]\n")?;

    writer.write_all(b"/// This file is autogenerated. Do not edit by hand!\n")?;

    writer.write_all(b"pub mod msgs {")?;

    for package in mods.values() {
        writer.write_all(format!("pub mod {package} {{").as_bytes())?;

        // TODO: redo msgs structure, don't keep looping
        for (msg_path, msg) in msgs.iter() {
            let parent_path = msg_path.parent().unwrap();
            if parent_path.file_stem().unwrap() != "msg" {
                continue;
            }
            let parent_path = parent_path.parent().unwrap();
            match mods.get(parent_path.to_str().unwrap_or("")) {
                Some(cur_package) => {
                    if package != cur_package {
                        continue;
                    }
                    writer.write_all(
                        "#[derive(Clone, Debug, serde::Deserialize, PartialEq)]".as_bytes(),
                    )?;
                    writer.write_all(msg.as_struct_definition().as_bytes())?;
                    write!(writer, "impl frost::msgs::Msg for {} {{}}", msg.name)?;
                }
                None => println!("WARN: missing package for {}", &msg_path.to_string_lossy()),
            };
        }

        writer.write_all("}".as_bytes())?;
    }

    writer.write_all("}".as_bytes())?;

    Ok(())
}

fn get_mods_and_msgs(
    input_path: &PathBuf,
) -> Result<(HashMap<String, String>, Vec<(PathBuf, RosMsg)>), Error> {
    let mut packages = HashMap::<String, String>::new();
    let mut msgs = Vec::<(PathBuf, RosMsg)>::new();

    for entry in WalkDir::new(input_path).into_iter() {
        let Ok(entry) = entry else {
            continue;
        };

        let Ok(metadata) = entry.metadata() else {
            continue;
        };

        if !metadata.is_file() {
            continue;
        }

        let abs_path = entry.into_path().canonicalize().unwrap();

        let Some(extension) = abs_path.extension() else {
            continue;
        };

        if abs_path.file_name().unwrap() == "package.xml" {
            let Ok(package_name) = get_package_name(&abs_path) else {
                continue
            };
            packages.insert(
                abs_path.parent().unwrap().to_string_lossy().into_owned(),
                package_name,
            );
        } else if extension == "msg" {
            let msg = RosMsg::new(&abs_path)?;
            msgs.push((abs_path, msg));
        }
    }
    Ok((packages, msgs))
}

fn main() -> Result<(), Error> {
    use bpaf::Parser;
    let opts = build_parser().to_options().run();

    let (mods, msgs) = get_mods_and_msgs(&opts.input_path)?;

    write_all(&opts.output_path, mods, msgs)?;
    fmt_file(&opts.output_path)?;
    Ok(())
}
